const syntactic_sugar = (overall, curr) => new Proxy(curr ?? {}, {
	get: (target, prop) => {
		if (typeof prop === "symbol") {
			return target[prop];
		}

		if (["sym", "data"].includes(prop)) {
			return target[prop];
		}

		if (prop === "then") {
			// Due to nested promise flattening, we cannot allow a map to be promise-like.
			// We must forcefully undefine the `then` property, as otherwise it would be classified as a "thenable".
			// If access to `:then` is needed, you must use the property [":then"] instead.

			return undefined;
		}

		if (prop.startsWith(":")) {
			if (prop === ":then") {
				prop = "then";
			} else if (prop === ":sym") {
				prop = "sym";
			} else if (prop === ":data") {
				prop = "data";
			}
		}

		if (prop.includes(".")) {
			const [first, ...rest] = prop.split(".");
			return target[first][rest.join(".")];
		}

		if (prop.match(/[^a-zA-Z0-9_]/)) {
			throw new Error(`Illegal symbol: ${prop}`);
		}

		if (overall === undefined) {
			overall = {};
		}

		const result = (data) => {
			if (curr === undefined) {
				result.data = data;
			} else {
				curr.data.data = data;
			}

			return result;
		};

		Object.assign(result, overall);

		if (curr === undefined) {
			result.sym = prop;
		} else {
			curr.data = { sym: prop };
		}

		return syntactic_sugar(result, curr === undefined ? result : curr.data)
	},
});

/**
 * Constructs a uoe-enum instance, which behaves like a tagged union.
 * 
 * An enum instance consists of a symbol and optionally some data.
 * 
 * @example
 * 
 * const pet = enm.cat({ name: "Fluffy" });
 * const bate = enm.fish;
 * draw_animals(tup([pet, bate])({
 *   stroke: enm.no_stroke,
 *   fill: enm.with_fill.gradient(tup(enm.red, enm.blue))
 * }));
 */
export const enm = syntactic_sugar();
